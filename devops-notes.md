## Dockerfileüê≥

```dockerfile
#1
FROM golang:1.22.5-alpine

#2
WORKDIR /journey

#3¬∫
COPY go.mod go.sum ./

RUN go mod download && go mod verify

#4¬∫
COPY . .

#5¬∫
#WORKDIR /outrodir/app

#6¬∫
RUN go build -o ./bin/journey .

#7¬∫
EXPOSE 8080

#8¬∫
ENTRYPOINT [ "/journey/bin/journey" ]
```

**1¬∫** - FROM √© qual √© a linguagem que utilizamos no container que vamos criar, "de onde vamos partir", ele busca no dockerhub.
<br/> - Sempre utilizar uma tag de vers√£o espec√≠fica, olhar se tem muitos CVE's na vers√£o escolhida.
<br/> - Priorizar vers√£o alpine, que √© menor/mais enxuta, possui uma superf√≠cie de ataque menor.

**2¬∫** - Diret√≥rio de trabalho, se n√£o definido, √© adotado o diret√≥rio raiz, que n√£o √© uma boa pr√°tica. Ele cria a pasta com o nome definido.

**3¬∫** - Copiando os arquivos do projeto go.mod e go.sum respons√°veis por gerenciar as depend√™ncias do projeto, para dentro do container, jogando na raiz da nossa pasta `journey`.
<br> - Tendo os dois arquivos, vamos conseguir executar o comando que realiza esse processo. Para executar comandos no dockerfile utilizamos o comando **RUN**.

**4¬∫** - Ap√≥s instalarmos todas as depend√™ncias, precisamos buildar nossa aplica√ß√£o, por√©m nossos dados ainda n√£o est√£o dentro do container, para jogar tudo que temos no nosso projeto para o container, utilizamos o comando **COPY**, onde o primeiro `.` √© para pegar tudo que temos na raiz do nosso projeto, e o segundo `.` jogar para dentro da raiz do docker, nesse caso no nosso WORKDIR /journey.

**5¬∫** - √â poss√≠vel mudar de diret√≥rio a qualquer momento.

**6¬∫** - Executando o comando de build, onde o `-o` define o output, por ser um bin√°rio vamos definir que ele vai ser gerado e adicionado na pasta /bin/journey, lembrando que o caminho `./bin/journey` sim precisa do `.`, pois ele faz refer√™ncia ao diret√≥rio local(journey), e o segundo par√¢metro √© o `.` que faz refer√™ncia ao arquivo .go que precisa ser buildado, no caso journey.go.

**7¬∫** - A porta que ser√° exposta pelo container, no caso a 8080 por ser onde nossa aplica√ß√£o √© executada, se n√£o expormos a porta, a aplica√ß√£o vai executar sem ser poss√≠vel acessar.

**8¬∫** - Entrypoint √© o que esse container vai executar, qual o caminho do execut√°vel da aplica√ß√£o que desejamos executar no container.

---

## Buildando dockerfileüèó

Comando docker para criar imagem
```
docker build -t api-journey:v1 .
```

Podemos listar as imagens
```
docker image ls ou docker images
```

Executar a cria√ß√£o do nosso container
```
docker run --name api-journey -d -p 8080:8080 api-journey:v1
```
> Comando `-d` √© para rodar o container detached do terminal.

Verificar os containers rodando
```
docker ps -a
```

Se nosso container n√£o estiver rodando, podemos ver seu log utilizando o container ID
```
docker logs 514aa176536b
```

---

## Multi-Stage build‚ú®

Podemos ver que o tamanho da nossa imagem criada est√° bem alto, muito do que temos em nossa imagem s√£o arquivos do nosso projeto, por√©m, no final do dia, s√≥ precisamos do bin√°rio.

Temos uma imagem de API simples com quase 600MB de espa√ßo.

![tamanho-imagem-v1](https://github.com/user-attachments/assets/10d296fb-f1b7-4ed7-bd09-641d827c926d)

Para resolver isso podemos alterar nosso dockerfile para ter v√°rias etapas, como build e execu√ß√£o.

```dockerfile
#1¬∫
FROM golang:1.22.5-alpine as builder

WORKDIR /app

COPY go.mod go.sum ./

RUN go mod download && go mod verify

COPY . .

RUN go build -o /bin/journey .

#2¬∫
FROM scratch

WORKDIR /app

#3¬∫
COPY --from=builder /bin/journey .

EXPOSE 8080

ENTRYPOINT [ "./journey" ]
```

**1¬∫** - Demos um alias a nosso processo, tudo que tiver de opera√ß√µes at√© o pr√≥ximo `FROM` eu estou chamando de `builder`.

**2¬∫** - Nesse segundo est√°gio, inicio nosso container com base no [scratch](https://hub.docker.com/_/scratch), uma imagem docker que tem apenas o b√°sico para um sistema ser executado.

**3¬∫** - Conseguimos se comunicar entre est√°gios, onde copiamos o que tem dispon√≠vel em /bin/journey do est√°gio `builder` e colamos na raiz do nosso novo est√°gio.

Ap√≥s essa altera√ß√£o, podemos criar nossa imagem novamente e visualizarmos se houve altera√ß√£o no tamanho de nossa imagem.

![tamanho-imagem-v2](https://github.com/user-attachments/assets/d137bb58-96c3-4b16-8950-49d026535bff)

Tivemos uma diminui√ß√£o de 96.95% no tamanho da nossa imagem.

---

## CI com github actions

√â poss√≠vel criar esse arquivo pelo github, mas caso queiramos criar a pasta e o arquivo `.github/workflows/main.yml` tamb√©m √© poss√≠vel.

```yaml
#1¬∫
name: CI

#2¬∫
on:
  push:
    branches:
      - master

#3¬∫
jobs:
  #4¬∫  
  build-and-push:
    name: "Build and Push"
    runs-on:  ubuntu-latest

    #5¬∫
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build docker image
        run: docker build -t sandrolax/api-journey:latest .

```

**1¬∫** - Nome do nosso workflow

**2¬∫** - Define quando √© trigado nosos workflow, no caso, quando houver um push na branch master.

**3¬∫** - O job √© uma m√°quina em execu√ß√£o e essa m√°quina tem v√°rios steps, podemos definir v√°rios jobs com v√°rios steps(teste/build/etc).

**4¬∫** - Nome do meu job e onde ele vai ser executado.

**5¬∫** - Steps s√£o os passos que desejo realizar quando o job processar, no nosso caso fazemos o `Checkout` que √© um [actions](https://github.com/actions/checkout)(steps pr√©-prontos) que basicamente √© um check out da branch no workspace, ap√≥s isso realizamos o step de buildar a imagem da nossa api.

Como o objetivo √© em breve enviar para o container registry do dockerhub, precisamos colocar o nosso nome de usu√°rio do dockerhub na frente do nome da imagem.

---

### Melhorias na action

**Gerar TAG imagem com base hash do commit**: Para isso criamos um step anterior a cria√ß√£o da imagem e utilizando a v√°riavel $GITHUB_SHA que est√° presente no contexto, tempos acesso ao hash, ap√≥s isso pegamos os 7 primeiros caracteres.

step:
```yaml
- name: Generate SHA
  id: generate_sha
  run: |
    SHA=$(echo $GITHUB_SHA | head -c7)
    echo "sha=$SHA" >> $GITHUB_OUTPUT
```

* Id para identificar os valores criados nesse passo.
* O pipe √© utilizado para definirmos comandos que tenham mais de uma linha.
* SHA recebe os 7 primeiros caracteres do hash do commit
* Criamos uma vari√°vel para adicionar o valor de SHA no output desse step. Todo step tem o output do anterior, uma maneira centralizada de ir passando informa√ß√µes entre os steps.

Ap√≥s criado e adicionado na vari√°vel `GITHUB_OUTPUT`, podemos utilizar para definir a tag da cria√ß√£o da nossa imagem. Abaixo temos um exemplo de como acessar esse valor no step de build.

```yaml
- name: Build docker image
  run: docker build -t sandrolax/api-journey:${{ steps.generate_sha.outputs.sha }} .
```

**Login no container registry**: Para fazer isso, vamos utilizar o action [Docker Login](https://github.com/marketplace/actions/docker-login), nele precisamos passar o usu√°rio e senha(token) do registry que vamos utilizar.

Utilizando o DockerHub passo o nome do meu user e o token √© gerado no dockerhub em Account settings > Security > New Access Token.

Para utilizar essas informa√ß√µes, como uma boa pr√°tica, vamos utilizar os secrects do github para setar os dados, isso est√° dispon√≠vel em Settings(Do reposit√≥rio) > Security > Actions > New Repository secret.

Abaixo o step criado:
```yaml
- name: Login to Docker Hub
  uses: docker/login-action@v3
  with:
    username: ${{ secrets.DOCKERHUB_USERNAME }}
    password: ${{ secrets.DOCKERHUB_TOKEN }}
```

**Enviando imagem para container registry**: Criamos o step e adicionamos o docker push, comando que envia a imagem criada para o dockerhub. Quanto √† tag podemos defini-la utilizando o comando docker tag.

Step criado:
```yaml
- name: Push to registry
  run: | 
    docker push sandrolax/api-journey:${{ steps.generate_sha.outputs.sha }}
    docker tag sandrolax/api-journey:${{ steps.generate_sha.outputs.sha }} sandrolax/api-journey:latest
    docker push sandrolax/api-journey:latest
```
> Boa pr√°tica

**Utilizando action para realizar o build e push**: O que fizemos manualmente at√© o momento funciona, por√©m, n√£o √© a melhor pr√°tica e est√° bem verboso. Vamos utilizar a [action ](https://github.com/marketplace/actions/build-and-push-docker-images) para melhorar essa parte do nosso workflow.

Revisando, ficar√° da seguinte forma:
```yaml
- name: Build and push
  uses: docker/build-push-action@v6
  with:
    context: .
    push: true
    tags: |
    sandrolax/api-journey:${{ steps.generate_sha.outputs.sha }}
    sandrolax/api-journey:latest
```

**Steps adicionais**: Poderiamos adicionar tamb√©m um step para realizar os testes unit√°rios, para isso √© necess√°rio ter o go na m√°quina onde roda o job, ent√£o precisamos instalar o go e ent√£o rodar os testes unit√°rios.

Exemplo abaixo:
```
- name: Setup Go
uses: actions/setup-go@v5
with:
    go-version: "1.22.5"

- name: Run tests
run: go test
```

---

## Kubernetes‚öì

### Arquitetura kube

![Components of kube](https://kubernetes.io/images/docs/components-of-kubernetes.svg)

**Node**: S√£o os componentes de trabalho, os n√≥s se comunicam com o control plane atrav√©s do kubelet e tem uma camada de rede que √© o kube-proxy. Conceitos como deployment, pod, deamonSet, service, ingress est√£o nesse componente. Para mais informa√ß√µes, consulte a [documenta√ß√£o](https://kubernetes.io/docs/concepts/architecture/nodes/).
**Control Plane**: √â o que gerencia globalmente nosso cluster, componentes de rede, scheduler, api, etcd(banco chave valor).  √â o cara que, se cair, temos um baita problema. Para mais informa√ß√µes, consulte a [documenta√ß√£o](https://dockerlabs.collabnix.com/kubernetes/beginners/Kubernetes_Control_Plane.html).
**Scheduler**: √â quem tenta alocar nossa aplica√ß√£o em um determinado n√≥. [Documenta√ß√£o](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/)

---

### Namespace

√â uma divis√£o l√≥gica para garantir uma melhor organiza√ß√£o na execu√ß√£o dos nossos pods. [Mais detalhes](https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/namespace-v1/).

Criando via comand line:
```
kubectl create namespace journey
```

---

### Secret

S√£o objetos onde podemos adicionar dados sens√≠veis, possuem uma estrutura chave/valor e encoda em base64 nossos segredos. Por n√£o ser uma estrutura que criptografa os dados, n√£o √© recomendada a utiliza√ß√£o em produ√ß√£o. Para mais detalhes, acesse a [documenta√ß√£o](https://kubernetes.io/docs/concepts/configuration/secret/).

Exemplo de secret:
```yaml
apiVersion: v1
kind: Service

metadata:
  name: journey-service
  labels:
    app: journey

spec:
  selector:
    app: journey
  type: ClusterIP
  ports:
    - name: journey-service
      port: 80
      targetPort: 8080
      protocol: TCP
```

Para aplicar o secret podemos utilizar o comando:
```
kubectl apply -f k8s/secret.yaml -n journey
```

> Realizar no diret√≥rio que possui o yaml e definir o namespace

---

### Deployment

√â a forma declarativa de definir o funcionamento de um replicaset e seus respectivos pods. Nele podemos utilizar outros recursos criados em nosso cluster, como, por exemplo, os secrets. Para mais sobre, [documenta√ß√£o](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/deployment-v1/).

Exemplo deployment:
```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: journey-deployment
  labels:
    app: journey

spec:
  replicas: 5
  selector:
    matchLabels:
      app: journey
  template:
    metadata:
      labels:
        app: journey
    spec:
      containers:
        - name: api-journey
          image: sandrolax/api-journey:4388865
          env:
            - name: JOURNEY_DATABASE_USER
              valueFrom:
                secretKeyRef:
                  name: db-connection
                  key: db_user
            - name: JOURNEY_DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: db-connection
                  key: db_password
            - name: JOURNEY_DATABASE_HOST
              valueFrom:
                secretKeyRef:
                  name: db-connection
                  key: db_host
            - name: JOURNEY_DATABASE_PORT
              valueFrom:
                secretKeyRef:
                  name: db-connection
                  key: db_port
            - name: JOURNEY_DATABASE_NAME
              valueFrom:
                secretKeyRef:
                  name: db-connection
                  key: db_name
          ports:
            - containerPort: 8080
          resources: 
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 128Mi
```

Para aplicar √© similar a secret:
```
kubectl apply -f k8s -n journey
```

> Por padr√£o, ele busca o arquivo deployment na pasta e o executa.

---

### Service

√â uma maneira de expor a rede do cluster, para conseguirmos acessar a aplica√ß√£o que est√° nos pods, na confirgura√ß√£o do service precisamos definir como ir√° funcionar a rede interna deles, ap√≥s isso realizar um [port-forward](https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/) para externalizar a rede interna para o da m√°quina que executa o k8s. Documenta√ß√£o sobre [service](https://kubernetes.io/docs/concepts/services-networking/service/).

Exemplo de service:
```yaml
apiVersion: v1
kind: Service

metadata:
  name: journey-service
  labels:
    app: journey

spec:
  selector:
    app: journey
  type: ClusterIP
  ports:
    - name: journey-service
      port: 80
      targetPort: 8080
      protocol: TCP
```

Aplicando service:
```
kubectl apply -f k8s/service.yaml -n journey
```

Executando o port-forward:
```
kubectl port-forward svc/journey-service 8080:80 -n journey
```

> Sempre importante lembrar de passar o namespace na execu√ß√£o dos comandos

Para mais informa√ß√µes sobre o kube consultar o reposit√≥rio [study-k8s](https://github.com/Sandrolaxx/study-k8s) e tamb√©m a [documenta√ß√£o oficial](https://kubernetes.io/docs/home).